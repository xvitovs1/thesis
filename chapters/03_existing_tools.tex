\section{LLVMPin Instrumentation Framework}

LLVMPin~\cite{llvmpin} is a framework that simplifies implementing tools for
LLVM~IR instrumentation. The framework basically consists of two scripts:

\begin{itemize}
    \item \texttt{llvmpin-gen} runs the LLVMPin tool implemented by
          user and instruments a given code,
    \item \texttt{llvmpin} generates a new
	  bitcode after instrumentation and from the bitcode it produces an
          executable.
\end{itemize}

The user has to implement a LLVMPin tool, which is a C++ code that must contain three
parts:

\begin{itemize}
    \item \texttt{REQUIRE} routine with a list of existing LLVM
          passes\footnote{\url{http://llvm.org/docs/WritingAnLLVMPass.html}} required by
          the LLVMPin tool,
    \item \texttt{INSTRUMENT} routine that inserts calls to analysis functions
          defined by user,
    \item analysis part that contains definitions of analysis functions and a
          routine for analysis setup.
\end{itemize}

The framework provides the user with API that adds several functions and macros
that are useful for the instrumentation, for example a function
\texttt{INS\_InsertCall} that adds a call to an analysis function. However,
although the LLVMPin framework is one of the instrumentation tools that are
general and configurable, it does not simplify the work for the user in terms
of writing a code that performs the core of the instrumentation process.

\section{Other Tools}

In this section, we describe tools that are not designed for general
instrumentation but use instrumentation over LLVM for various purposes.

Clang compiler provides several sanitizers that use instrumentation to insert
runtime checks for various errors and undefined behaviour. It offers a memory
error detection (out-of-bounds dereferences, use-after-free, double-free, etc.)
with AddressSanitizer~\cite{asan}, that instruments each memory access with a
check to a \textit{shadow memory}. The shadow memory contains metadata about
corresponding program memory, mainly \textit{poisoned redzones} that mark
locations of the memory that should not be accessed.
ThreadSanitizer~\cite{tsan} is used for detection of data races in parallel
programs. The analyzed code is instrumented such that it keeps information
about each memory access and checks whether the access takes part in a race.
UndefinedBehaviourSanitizer offers undefined behaviour detection (e.g. integer
overflows) by instrumenting all operations that may lead to undefined behaviour
with a check. All these sanitizers modify the code during compilation and
insert run-time checks. Disadvantage is slowdown and memory overhead these tool
introduce.

SAFECode~\cite{safecode} (Static Analysis For safe Execution of Code) is a tool
developed at University of Illinois that checks memory safety properties, such
as accessing valid memory locations, out-of-bounds accesses, invalid frees and
detection of dangling pointers. Like Clang sanitizers it inserts run-time
checks at compile-time. Moreover, it uses static analysis to minimize the
number of inserted run-time checks.

Another tool that uses instrumentation to check memory safety properties is
Map2Check. Like Symbiotic, it uses KLEE as symbolic executor. \todo{describe
later from their paper}

Loom is an LLVM library for instrumentation that enables to insert lines of
code that expose values of LLVM instruction (e.g. return values of function
calls). In contrast to the above mentioned tools, it is in a sense
configurable. Users can specify what functions should be instrumented, whether
they should be instrumented on the caller site or the callee site, what
structures should be instrumented and whether they should be instrumented on
reads or writes, etc.

LLVM IR Trace Profiler~\cite{tracer} (LLVM-Tracer) is an LLVM pass that, like Loom,
instruments the given code to expose values. It traces dynamic register values
as well as memory addresses.
