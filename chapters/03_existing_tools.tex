\section{LLVMPin Instrumentation Framework}

\url{http://eces.colorado.edu/~blomsted/llvmpin/llvmpin.html}
\medskip

LLVMPin is a framework that simplifies implementing tools for LLVM~IR
instrumentation. The framework basically consists of two scripts:

\begin{itemize}
    \item \texttt{llvmpin-gen} runs the LLVMPin tool implemented by
          user and instruments a given code,
    \item \texttt{llvmpin} generates a new
	  bitcode after instrumentation and from the bitcode it produces an
          executable.
\end{itemize}

The user has to implement a LLVMPin tool, which is a C++ code that must contain three
parts:

\begin{itemize}
    \item \texttt{REQUIRE} routine with a list of existing LLVM
          passes\footnote{\url{http://llvm.org/docs/WritingAnLLVMPass.html}} required by
          the LLVMPin tool,
    \item \texttt{INSTRUMENT} routine that inserts calls to analysis functions
          defined by user,
    \item analysis part that contains definitions of analysis functions and a
          routine for analysis setup.
\end{itemize}

The framework provides the user with API that adds several functions and macros
that are useful for the instrumentation, for example, one of the basic
functions provided by the API is a function \texttt{INS\_InsertCall} that adds
a call to an analysis function. However, although the LLVMPin framework is one
of the instrumentation tools that are general and configurable, it does not
simplify the work for the user in terms of writing a code that performs the
core of the instrumentation process.


\section{LLVM-IR-MemProtect}

\url{https://github.com/toaarnio/llvm-ir-memprotect}

\section{LLVM IR Trace Profiler}

\url{https://github.com/ysshao/LLVM-Tracer#llvm-ir-trace-profiler-llvm-triacer-12}

\section{LLVM Instrumentation Pass}

\url{https://github.com/imdea-software/LLVM\_Instrumentation\_Pass}

\section{Other Tools}

In this section, we describe tools that are not designed for general
instrumentation but use instrumentation over LLVM for various purposes.

\url{https://clang.llvm.org/docs/UsersManual.html#id34}

Clang compiler provides several sanitizers that use instrumentation to insert
runtime checks for various errors and undefined behaviour. It offers a memory
error detection with AddressSanitizer
\textcolor{red}{\url{https://clang.llvm.org/docs/AddressSanitizer.html}}
(out-of-bounds dereferences, use-after-free, double-free, etc.), a detection of
data races in parallel programs with ThreadSanitizer or undefined behaviour
detection with UndefinedBehaviorSanitizer (e.g. integer overflows). All these
sanitizers modify the code during compilation and insert run-time checks.
Disadvantage is slowdown and memory overhead these tool introduce.

SAFECode (Static Analysis For safe Execution of Code)
\url{http://safecode.cs.illinois.edu/index.html} is a project developed at
University of Illinois that checks memory safety properties, such as accessing
valid memory locations, out-of-bounds accesses, invalid frees and detection of
dangling pointers. Like Clang sanitizers it inserts run-time checks at
compile-time. Moreover, it uses static analysis to minimize the number of
inserted run-time checks.

Another tool that uses instrumentation is Map2Check. Like Symbiotic, it uses
KLEE as symbolic executor and instruments the code that is being analyzed to
check memory safety properties.
