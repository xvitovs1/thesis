As only one of the tools described in Chapter~\ref{chap:tools} can be used for
an instrumentation of user's choice, we decided to implement a tool for general
instrumentation that would be configurable by user. Moreover, the user
would not need to implement the core of instrumentation routine as with
\llvmpin (see Section~\ref{sec:llvmpin}).

\smartdiagramset{%
  back arrow disabled=true,
  module minimum width=2cm,
  module minimum height=2cm,
  module x sep=3cm,
  text width=2cm,
  additions={
    additional item offset=0.5cm,
    additional item border color=red,
    additional arrow color=red,
    additional item width=2cm,
    additional item height=2cm,
    additional item text width=3cm
  }
}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[yscale=0.9, auto,
      block/.style = {
        rectangle, draw=black, thick, text width=8em, text centered,
        rounded corners, minimum height=3em },
      block-sharp/.style = {
          rectangle, draw, thick, text width=8em, text centered, minimum
          height=3em },
      line/.style = { draw, thick, ->, >=stealth },
      line-dashed/.style = { draw, thick, ->, densely dotted, >=stealth }]
    \node [block-sharp] (rules) at (-4.5, -2.75) {\textsf{Instrumentation\\ rules in JSON}};
    \node [block-sharp] (cprogram) at (0, 2.25) {\textsf{Program in C}};
    \node [block-sharp] (llvmprogram) at (0, 0) {\textsf{Program in LLVM}};
	\node [rectangle split, draw, rectangle split parts=2, text
    width=8em,rounded corners, text centered, fill=blue!30] (instr) at (0, -2.75)
    {\textsf{\textbf{Instrumentation:}} \nodepart{second}
    \parbox{3cm}{\textsf{1. phase \\ 2. phase \\ \vdots}}};
    \node [block-sharp] (instrprogram) at (0, -5.5) {\textsf{Instrumented program in LLVM}};
    \node [block-sharp] (defs) at (4.5, -2.75) {\textsf{Definitions of
    instrumented functions in LLVM}};
    % connect all nodes defined above
    \draw[line] (cprogram) -> (llvmprogram);
    \draw[line-dashed] (llvmprogram) -> (instr);
    \draw[line] (instr) -> (instrprogram);
    \draw[line-dashed] (rules) -> (instr);
    \draw[line-dashed] (defs) -> (instr);
  \end{tikzpicture}
  \caption{The scheme of configurable instrumentation.}
  \label{fig:scheme}
\end{figure}

The basic idea of our instrumentation tool is depicted in
Figure~\ref{fig:scheme}. Since it works on top of LLVM, a program in C that is
supposed to be instrumented has to be translated to LLVM first. Instrumentation
is required to be configurable, therefore it needs to be supplied with two
config files created by a user: a~file with definitons of instrumentation
functions translated into LLVM whose calls will be inserted into the code and a
JSON file with instrumentation rules. The rules define how sequences of LLVM
instructions should be instrumented with calls of instrumentation functions.
For now, we only allow to insert call instructions since it is sufficient as
any other demanded instruction can be wrapped in the called function.

The instrumentation proceeds in one or more phases, each phase containing a set
of instrumentation rules.The tool goes through all instructions of the module
loaded from given LLVM file in each phase and it looks if the instructions
match any instrumentation rule of the current phase. If a match is found, the
rule is applied (i.e.~a~new code is inserted according to the rule). The result
of the instrumentation process is again an LLVM program.

The phased instrumentation is useful because it allows the user to gather some
information in earlier phases and to use it in later phases. For example, it is
pointless to insert a check for memory leaks if there is no call to
\emph{malloc} in the program. Therefore, the presence of a call to
\emph{malloc} can be noted in the first phase, and the check for memory leaks
can be inserted in a later phase according to the noted information.

\section{Flags and Plugins}

In order to pass some information between phases, a user can define flags in a
JSON file with instrumentation rules. When inserting a call to a function, it
is possible to set a flag and, in a later phase, condition some rule by a check
whether the flag is set to the given value (see section~\ref{sec:conditions}).
For example, the user might want to set a flag \texttt{malloc-instrumented} to
\emph{true} when instrumenting a call to \emph{malloc} in the first phase of
the instrumentation, and to insert a check for memory leaks at the end of
\emph{main} in the second phase only if the flag is set to \emph{true}, i.e. if
there is a call to \emph{malloc} somewhere in the program.

The instrumentation module can also be extended by plugins that can reply to
queries, which are basically questions that can be decided by a plugin. To
define a list of possible queries, plugins have to implement the same
interface. The interface describes a set of callbacks that correspond to the
queries and return string values. For example, a query "Can pointers
\texttt{p1} and \texttt{p2} point to the same memory location?" can correspond
to a callback \texttt{pointersCanBeEqual(p1, p2)}. These functions can be
redefined by concrete plugins that are able to decide the corresponding
queries, e.g.  the function \texttt{pointersCanBeEqual} can be redefined by a
plugin for a pointer analysis, since with this analysis it is possible to
determine whether two pointers can point to the same memory location. Since
each plugin is focused on only a~subset of queries, i.e. it is able to answer
to only a subset of the queries, there are default answers for queries that
cannot be decided by the given plugin. The default answers are neutral and
should not influence the instrumentation. For example, the default answer for
the query "Can pointers \texttt{p1} and \texttt{p2} point to the same memory
location?" can be \emph{"unknown"}.

Currently, the following queries are available:
\begin{description}
  \item[isValidPointer(p, len)] Is a dereference of a pointer \texttt{p} of
        length \texttt{len} valid operation?
  \item[hasKnownSize(object)] Can we statically determine the size of the memory
         object that is being dereferenced?
  \item[pointsTo(p,a)] Does the given pointer \texttt{p} point to the value \texttt{a}?
  \item[isNull(p)] Does the given pointer \texttt{p} point to NULL?
\end{description}
There are four possible answers for these queries: \emph{"true"},
\emph{maybe}, \emph{"false"} and \emph{"unknown"}. The default answer for all
these queries is \emph{"unknown"} and is supposed to be used by the plugins
that are not able to evaaluate the query.

The list of queries can be easily appended by adding more callbacks that return
string values to the interface and by \todo{change this in the code} adding a
handler for this query in the class \texttt{Analyzer}.

\section{Conditions}\label{sec:conditions}

To enable conditional instrumentation, the rules can be extended with
conditions. To apply a rule, all conditions for the rule have to be satisfied.

The very first idea was to implement the conditions as lists of predicates over
values from the program that is being verified. Since static analyses provided
by plugins are supposed to be over-approximating, the predicates were set to
reason about possibilities (e.g. may the pointer be invalid?). The static
analyses could answer either \emph{true} or \emph{false}, therefore answering
\emph{true} was a conservative answer if an analysis did not have enough
information to refute the predicate. A condition was evaluated as \emph{true}
if all plugins answered that it was satisfied. If at least one plugin said that
the condition was not satisfied, the condition was evaluated as \emph{false}.

However, we later found a drawback of this method when we needed to use
conditions that do not ask about possibilities but need an accurate answer
(e.g. is the size of this allocated memory known at compile-time?). The method
worked fine if only one plugin was available, because the condition was
evaluated according to one reply from this plugin, but when we added more
plugins, we ran into problems. We needed the conditions that ask if some
statement may hold to evaluate to \emph{true} if all plugins answer
\emph{true} because of the over-approximations and at the same time we needed
some conditions that ask if some statement really holds to evaluate to
\emph{true} if at least one plugin answeres \emph{true}.

Our solution was to define a condition as a query that can take values from the
program being verified as parameters, and a list of expected answers. There are
two types of these conditions:
\begin{itemize}
 \item conditions that check whether a flag is set to the given value, i.e. the
 query is the name of the flag and the list of expected results contains the
 given value,
 \item conditions that check answers of plugins to given queries.
\end{itemize}
Answers of plugins are now not limited only to \emph{true} or \emph{false} but
can reply with a string. A plugin can now for example answer also with
\emph{"maybe"}. A condition is satisfied if and only if some answer from a
plugin equals one of the values in the list of expected answers. This solves
the above mentioned problem as the list of expected answers for queries about
possibilities can contain both \emph{"true"} and \emph{"maybe"} and the list
of expected answers for queries that expect accurate answer can contain just
\emph{"true"}.

\section{Configuration}\label{sec:config}

In this section, we describe the structure of a JSON file in which
instrumentation rules are defined.

Variables in this configuration file are enclosed by the '<' and '>'
characters. These variables can be used to store some values for later use. For
example, to store an operand of a \texttt{load} instruction to the variable
\texttt{<t>}, a field \texttt{operands} that will correspond to the operands of
\texttt{load} instruction will be set to \texttt{["<t>"]}.  Variable
\texttt{<t>} will contain the value of the operand of \texttt{load} instruction
in the scope of the application of the current rule and it can be used e.g. as
an argument of the function call that is to be instrumented or as an argument
of a condition.

A JSON file with instrumentation rules has to contain the following fields:

\begin{center}
\begin{tabular}[h]{>{\bfseries}p{4.2cm} | p{7.8cm}}
  \texttt{file}                & Path to a file with definitions of instrumentation functions. \\
  \hline
  \texttt{analyses}            & List of paths to plugins. \\
  \hline
  \texttt{flags}               & List of flags that can be set during instrumentation. \\
  \hline
  \texttt{phases}              & List of instrumentation phases. Each phase contains a
                                 list of \texttt{instructionRules}. \\
  \hline
  \texttt{globalVariablesRule} & A rule for instrumenting global
                                 variables.

\end{tabular}
\end{center}

Each element of \texttt{instructionRules} is an JSON object described with
several fields:
\begin{description}
    \item[\texttt{findInstructions}] Sequence of instructions we are searching
    for. For each instruction in the sequence, we need to fill in a field
        \texttt{instruction}, that specifies a name of the instruction that has
        to be matched, \texttt{returnValue} that enables to remember the return
        value of the instruction in a given variable (can be set to "*" if the
        return value is not needed), and \texttt{operands} that enables either
        to match the operands or to remember the operand values in given
        variables. We can also optionally fill in fields \texttt{getTypeSize}
        and \texttt{getPointerInfo}. \texttt{getTypeSize} can be used only with
        \texttt{load}, \texttt{store} or \texttt{alloca} instruction and it
        stores size of the type of the value that is being loaded, stored or
        allocated to the given variable. \texttt{getPointerInfo} can be used
        only with \texttt{load} or \texttt{store} and it stores two values to
        given variables (if possible): size of the allocated memory to which
        the dereferenced pointer points to and corresponding \texttt{alloca}
        instruction. Since we can get this information only from a pointer
        analysis, this field can be used only when the analysis is available as
        a~plugin.

        In Figure~\ref{fig:findInstrs_example} we give an example of
        a \texttt{findInstructions} field. We are searching for a sequence of
        instructions of length one, namely for a \texttt{store} instruction.
        Since \texttt{store} does not return any value, the
        \texttt{returnValue} field is set to "*". The two operands of
        \texttt{store} will be stored in variables \texttt{<t1>} and
        \texttt{<t2>}, size of the type of the value that is being stored will
        be kept in the variable \texttt{<t3>}. \texttt{<t4>} will contain the
        size of the allocated memory to which the pointer in \texttt{<t2>}
        points to and \texttt{<t5>} will contain the \texttt{alloca}
        instruction that allocated this memory.

        \begin{minipage}{\linewidth}
        \lstset{
            basicstyle=\footnotesize,
            string=[s]{"}{"},
            stringstyle=\color{blue},
            comment=[l]{:},
            commentstyle=\color{black},
        }
        \lstinputlisting{examples/findInstrs.json}
        \captionof{figure}{Example of a \texttt{findInstructions} field in a
        JSON configuration file.}
        \label{fig:findInstrs_example}
      \end{minipage}

    \item[\texttt{newIstruction}] A new instruction that is to be inserted. It
    contains two mandatory fields: \texttt{instruction} that specifies a name
    of the new instruction (for now, only \texttt{call} instruction is
    supported), and \texttt{operands} of the instruction. For example, a
    \texttt{newInstruction} field in Figure~\ref{fig:newInstr_example} means
    that if the tool decides to apply the rule, a call to a function
    \texttt{\_\_INSTR\_check\_pointer} will be inserted and values of
    \texttt{<t1>} and \texttt{<t2>} will be passed as arguments of the
    function.

     \begin{minipage}{\linewidth}
        \lstset{
            basicstyle=\footnotesize,
            string=[s]{"}{"},
            stringstyle=\color{blue},
            comment=[l]{:},
            commentstyle=\color{black},
        }
        \lstinputlisting{examples/newInstr.json}
        \captionof{figure}{Example of a \texttt{newInstruction} field in a
        JSON configuration file.}
        \label{fig:newInstr_example}
      \end{minipage}

    \item[\texttt{in}] Name of a function, in which this rule should be
    applied. Can be set to a value "*" meaning that it should be used in all
    functions.

    \item[\texttt{where}] Specifies the location of insertion. It can be:
    \texttt{before} or \texttt{after} the found sequence of instructions,
    \texttt{entry} (at the entry point of the given function, \texttt{in}
    cannot be set to "*" in this case) or \texttt{return} (before every
    \texttt{return} instruction of the given function, \todo{\texttt{in} cannot be
    set to "*" in this case}).

    \item[\texttt{conditions}] List of conditions that have to be satisfied
    (see section~\ref{sec:conditions}). A condition consists of fields
    \texttt{query} and \texttt{expectedResult}. \texttt{Query} is a list
    where the first element is the name of a query and other elements are
    parameters passed to the the query, \texttt{expectedResult} is a list of
    expected results of the query.

    In Figure~\ref{fig:conditions_example} a \texttt{conditions} list contains
    two conditions that have to be satisfied for the rule to be applied. The
    first condition is a query for plugins. This condition will be satisfied if
    at elast one of the plugins will answer \emph{false} or \emph{"unknown"} to
    the query \texttt{isValidPointer} with values of \texttt{<t1>} and
    \texttt{t2} passed as parameters. The second condition will be satisfied if
    the flag \texttt{testFlag} is set to \emph{"true"}.

    \begin{minipage}{\linewidth}
        \lstset{
            basicstyle=\footnotesize,
            string=[s]{"}{"},
            stringstyle=\color{blue},
            comment=[l]{:},
            commentstyle=\color{black},
        }
        \lstinputlisting{examples/condition.json}
        \captionof{figure}{Example of a \texttt{conditions} field in a
        JSON configuration file.}
        \label{fig:conditions_example}
      \end{minipage}

    \item[\texttt{setFlags}] List of pairs \texttt{[flag, value]} that sets all
    \texttt{flags} to the corresponding \texttt{value} if the rule was applied.
    This field is optional. We give an example of this field in
    Figure~\ref{fig:setFlags_example}, which sets the flag \texttt{loadPresent}
    to \emph{"true"} and the flag \texttt{testFlag} to \emph{false}.

     \begin{minipage}{\linewidth}
        \lstset{
            basicstyle=\footnotesize,
            string=[s]{"}{"},
            stringstyle=\color{blue},
            comment=[l]{:},
            commentstyle=\color{black},
        }
        \lstinputlisting{examples/set_flags.json}
        \captionof{figure}{Example of a \texttt{setFlags} field in a
        JSON configuration file.}
        \label{fig:setFlags_example}
      \end{minipage}

    \item[\texttt{remember}] Specifies, which variable will be remembered in an
    auxiliary list for later use if the rule is applied. This field is optional.
\end{description}

\medskip

\noindent A \texttt{globalVariablesRule} can be used for instrumenting global
variables and it is a JSON object with the following fields:
\begin{itemize}
    \item \texttt{findGlobals:} Contains a mandatory field
    \texttt{globalVariable} that stores a value of a global variable to the
    given variable, and an optional field \texttt{getSizeTo} that gets the size
    of the type of the global variable. The field \texttt{findGlobals} in
    Figure~\ref{fig:findGlobals_example} stores the value of a global variable
    to the variable \texttt{<t1>} and stores the size of its type in
    \texttt{<t2>}.

    \begin{minipage}{\linewidth}
        \lstset{
            basicstyle=\footnotesize,
            string=[s]{"}{"},
            stringstyle=\color{blue},
            comment=[l]{:},
            commentstyle=\color{black},
        }
        \lstinputlisting{examples/findGlobals.json}
        \captionof{figure}{Example of a \texttt{findGlobals} field in a
        JSON configuration file.}
        \label{fig:findGlobals_example}
      \end{minipage}

    \item \texttt{newInstruction:} The same as in \texttt{instructionRule}.
    \item \texttt{in:} Name of a function, at the beginning of which the new
    instruction will be inserted.
    \item \texttt{conditions:} The same as in \texttt{instructionRule}.
\end{itemize}

The functions whose calls are instrumented into a code must be defined in a
file specified by the \texttt{file} field in the JSON configuration. The
function can be implemented in any language that can be translated into LLVM,
since the file with the functions is compiled to LLVM first and after a
successful instrumentation, it is linked to the instrumented module.

\section{Applying Rules}

In this section, we describe the process of applying the instrumentation
rules on a module loaded from the given LLVM program.

First, the rules from the JSON file are parsed. If there are some paths to
plugins specified, the plugins are loaded and the instrumentation part begins.

The instrumentation is implemented to be staged, therefore the first step is to
process all the phases one after each other in a following way: iterate over
functions from the loaded module and check rules from the phase being processed
that are relevant for the current function. That is, take into consideration
only rules where \texttt{in} field is set to "*" or to the name of the
function. Then compare the sequences of instructions defined by these rules
(field \texttt{findInstructions}) with instructions of the current function and
if some rule matches the sequence, begin to process the rule.

To process the rule, first of all, the values of operands and return values of
the matched instructions that are noted by the rule to be saved are stored to
given variables. If the fields \texttt{getTypeSize} or \texttt{getPointerInfo}
are present, the demanded information is stored to the given variables. Then
all conditions are checked as described in Section~\ref{sec:conditions}. If
they are satisfied, the rule is ready to be applied. The new \texttt{call}
instruction that is to be inserted is created according to
\texttt{newInstruction} field and injected before or after the matched sequence
of instruction according to \texttt{where} field. For now, we support only
inserting \texttt{call} instructions, however, it does not limit the user in
any way. Since functions whose calls will be inserted are defined by the user,
all other instructions can be inserted through these functions.

\lstset{escapeinside={<@}{@>}, columns=fullflexible, basicstyle=\ttfamily, language=llvm, style=nasm}
\begin{figure}[h]
\begin{lstlisting}
%result = add i32 5, 10
<@{\color[RGB]{0, 135, 0} \%1 = bitcast i32 \%result to i64}@>
<@{\color[RGB]{0, 135, 0} call void @\_\_INSTR\_log\_addition(i64 \%1)}@>
\end{lstlisting}
\caption{Instrumentation of a code where a bitcast is needed. The
\texttt{\_\_INSTR\_log\_addition} function takes a 64-bit integer as an
argument. The 32-bit integer \texttt{result} thus needs to be conevrted before
it is passed as the argument.}
\label{fig:bitcast_example}
\end{figure}
Since the parameters of the called function might be of different types than
values that are passed as these parameters, we might need to convert them
before the insertion of the new call. In this case, we first insert a
\texttt{bitcast} instruction that performs the needed conversion. For example,
in Figure~\ref{fig:bitcast_example}, the function
\texttt{\_\_INSTR\_log\_addition} that is to be called takes a 64-bit integer
as a parameter, but the value that we want to pass as the parameter
(\texttt{result}) is a 32-bit integer. Therefore, the instruction \texttt{bitcast
i32 result to i64} will be inserted before the new call instruction.

If the rule is successfully applied, flags are set according to the field
\texttt{setFlags} (if present). If the field \texttt{remember} is defined, the
given value is stored to an auxiliary list and can be used in a later phase of
instrumentation.

At the very end, after each phase from the configuration was processed, a rule
for global variables is applied. That is, a new instruction is inserted at the
beginning of the function given in \texttt{in} field if conditions are
satisfied.

Sometimes the program might contain definitions of functions that are never
called. Such functions can be omitted from the instrumentation process if a
plugin for a pointer analysis is available. To determine what functions are
called, we first need to build a call graph from the given program. The pointer
analysis is necessary for building this graph because functions can be called
indirectly through function pointers. Then we search the graph with
breadth-first search algorithm starting from the node that represents the
\emph{main} function. All functions (or nodes precisely) that were visited
during the search are marked as reachable. All the other functions are never
called and are not instrumented.

\lstset{
    basicstyle=\footnotesize,
    string=[s]{"}{"},
    stringstyle=\color{blue},
    comment=[l]{:},
    commentstyle=\color{black},
}

\begin{figure}[h]
\lstinputlisting{examples/json_example.json}
\caption{Example of an \texttt{instructionRule} in a JSON configuration file.}
\label{fig:json_example}
\end{figure}

In Figure~\ref{fig:json_example}, we can see an example of an
\texttt{instructionRule}. In this case, every time the tool comes across a
\texttt{load} instruction in any function (\texttt{in} is set to "*"), the only
operand of \texttt{load} is stored to a variable \texttt{<t1>}, size of the
type that is being loaded is stored to a variable \texttt{<t2>} and the condition
\texttt{isValidPointer} is checked by all plugins (i.e.~a~function
\texttt{isValidPointer} is called with arguments \texttt{<t1>} and
\texttt{<t2>} by all plugins). If some plugin answered either \emph{"false"} or
\emph{"unknown"}, the condition is satisfied and a call of the function
\texttt{\_\_INSTR\_check\_pointer} with arguments \texttt{<t1>} and
\texttt{<t2>} is inserted \emph{before} the current \texttt{load} instruction.
After a successful application of this rule, flag \texttt{loadPresent} is set
to \emph{true}.

\begin{figure}[h]
\lstinputlisting{examples/json_example2.json}
\caption{Example of an \texttt{globalVariablesRule} in a JSON configuration file.}
\label{fig:json_example2}
\end{figure}


An example of a \texttt{globalVariablesRule} can be found in
Figure~\ref{fig:json_example2}. The value of a global variable is stored to a
variable \texttt{<t1>} and size of the type of the global variable is stored to
a variable \texttt{<t2>}. Plugins are asked whether the given condition
\texttt{isRemembered} with argument \texttt{<t1>} holds and if the answer is
positive, a new call of the function \texttt{\_\_INSTR\_remember\_global} with
arguments \texttt{<t1>} and \texttt{<t2>} is inserted at the beginning of
\emph{main}.

\section{Logging}

To sum up the instrumentation process for a concrete file, each operation is
logged with a logger. The logger notes following operations:
\begin{itemize}
  \item parsing configuration
  \item loading plugins (also lists the names of the loaded plugins)
  \item the beginning and the end of each phase
  \item ommitting a function from instrumentation
  \item rule application and instruction insertion
  \item the end of instrumentation (also logs the name of the resulting file)
\end{itemize}
The logger also logs errors such as an error when parsing configuration, invalid
path to a plugin, unsupported instruction insertion, instrumentation of a
non-existing function, error when inserting a new instruction, etc. Logs can be
found in \emph{log.txt} file that is generated at the end of the
instrumentation process.

