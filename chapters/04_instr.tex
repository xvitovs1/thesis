\smartdiagramset{%
  back arrow disabled=true,
  module minimum width=2cm,
  module minimum height=2cm,
  module x sep=3cm,
  text width=2cm,
  additions={
    additional item offset=0.5cm,
    additional item border color=red,
    additional arrow color=red,
    additional item width=2cm,
    additional item height=2cm,
    additional item text width=3cm
  }
}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[yscale=0.9, auto,
      block/.style = {
        rectangle, draw=black, thick, text width=8em, text centered,
        rounded corners, minimum height=3em },
      block-sharp/.style = {
          rectangle, draw, thick, text width=8em, text centered, minimum
          height=3em },
      line/.style = { draw, thick, ->, >=stealth },
      line-dashed/.style = { draw, thick, ->, densely dotted, >=stealth }]
    \node [block-sharp] (rules) at (-4.5, -2.75) {\textsf{Instrumentation\\ rules in JSON}};
    \node [block-sharp] (cprogram) at (0, 2.25) {\textsf{Program in C}};
    \node [block-sharp] (llvmprogram) at (0, 0) {\textsf{Program in LLVM}};
	\node [rectangle split, draw, rectangle split parts=2, text
    width=8em,rounded corners, text centered, fill=blue!30] (instr) at (0, -2.75)
    {\textsf{\textbf{Instrumentation:}} \nodepart{second}
    \parbox{3cm}{\textsf{1. phase \\ 2. phase \\ \vdots}}};
    \node [block-sharp] (instrprogram) at (0, -5.5) {\textsf{Instrumented program in LLVM}};
    \node [block-sharp] (defs) at (4.5, -2.75) {\textsf{Definitions of
    instrumented functions in LLVM}};
    % connect all nodes defined above
    \draw[line] (cprogram) -> (llvmprogram);
    \draw[line-dashed] (llvmprogram) -> (instr);
    \draw[line] (instr) -> (instrprogram);
    \draw[line-dashed] (rules) -> (instr);
    \draw[line-dashed] (defs) -> (instr);
  \end{tikzpicture}
  \caption{The scheme of configurable instrumentation.}
  \label{fig:scheme}
\end{figure}

The basic idea of our instrumentation tool is depicted in
figure~\ref{fig:scheme}. Since it works on the top of LLVM, a program in C that
is supposed to be instrumented has to be translated. Instrumentation is
required to be configurable, therefore it needs to be supplied with two files:
a~file with definitons of instrumentation functions whose calls will be
inserted into the code and a JSON file with instrumentation rules. The rules
define how sequences of LLVM instructions should be instrumented with calls of
instrumentation functions. The tool first loads a~whole module from a given
LLVM code and begins to process it. In each phase it goes through all
instructions and it looks if they match any instrumentation rule. If a match is
found, the rule is applied (i.e.~a~new code is inserted according to the rule).
The result of the instrumentation process is again an LLVM program.

\section{Flags and Plugins}

In order to pass some information between phases, flags can be defined in a
JSON file with instrumentation rules. When inserting a call to a function, it
is possible to set a flag and, in a later phase, condition some rule by a check
whether the flag is set to the given value (see section~\ref{sec:conditions}).

The instrumentation module can also be extended by plugins that can reply to
queries. To define a list of possible queries, all plugins have to implement
the same interface. The interface consists of a set of virtual functions that
correspond to the queries and return default string values. For example, a
query "Do pointers \texttt{p1} and \texttt{p2} point to the same memory
location?" can correspond to a virtual function \texttt{pointersAreEqual(p1,
p2)} that returns \emph{"unknown"} by default. These functions can be redefined
by concrete plugins that are able to decide the corresponding queries, e.g.
the function \texttt{pointersAreEqual} can be redefined by a plugin for a
pointer analysis, since with this analysis it is possible to determine whether
two pointers point to the same memory location.

Currently, following queries are available:
\begin{description}
  \item[isValidPointer(p, len)] Is a dereference of a pointer \texttt{p} of
  length \texttt{len} valid operation?
  \item[hasKnownSize(block)] Can we statically determine the size of the
  \texttt{block} that is being dereferenced?
  \item[pointsTo(p,a)] Does the given pointer \texttt{p} point to the value \texttt{a}?
  \item[isNull(p)] Does the given pointer \texttt{p} point to NULL?
\end{description}
There are three possible answers for these queries:
\emph{"true"}, \emph{"unknown"} and \emph{"false"}. The default answer for all
these queries is \emph{"unknown"}.

The list of queries can be easily appended by adding more virtual functions
that return string values to the interface and by reimplementing the function
that links the queries with corresponding functions.

\section{Conditions}\label{sec:conditions}

To enable conditional instrumentation, the rules can contain lists of
conditions. To apply a rule, all conditions in the list have to be satisfied.

The very first idea was to implement the conditions as lists of predicates over
values from the program that is being verified. Since static analyses provided
by plugins are supposed to be over-approximating, the predicates are set to
reason about possibilities (e.g. may the pointer be invalid?). The static
analyses could answer either \emph{true} or \emph{false}, therefore answering
\emph{true} is a conservative answer if an analysis does not have enough
information to refiute the predicate. A condition is evaluated as \emph{true}
if all plugins answer that it is satisfied. If at least one plugin says that
the condition is not satisfied, the condition is evaluated as \emph{false}.

However, we later found a drawback of this method when we needed to use
conditions that do not ask about possibilities but need an accurate answer
(e.g. is the size of this allocated memory known at compile-time?). The method
worked fine if only one plugin was available, because the condition was
evaluated according to one reply from this plugin, but when we added more
plugins, we ran into problems. We needed the conditions that ask if some
statement may hold to evaluate to \emph{true} if all plugins answeres
\emph{true} because of the over-approximations and at the same time we needed
some conditions that ask if some statement really holds to evaluate to
\emph{true} if at least one plugin answeres \emph{true}.

Our solution was to define a condition as a query that can be parameterized
with values from the program being verified, and a list of expected results.
There are basically two types of these conditions:
\begin{itemize}
 \item conditions that check whether a flag is set to the given value, i.e. the
 query is the name of the flag and the list of expected results contains the
 given value,
 \item conditions that check answers of plugins to given queries.
\end{itemize}
Answers of plugins are now not limited only to \emph{true} or \emph{false} but
can reply with a string. A plugin can now for example answer also with
\emph{"unknown"}. A condition is satisfied if and only if some result from a
plugin equals one of the values in the list of expected results. This solves
the above mentioned problem as the list of expected results for queries about
possibilities can contain both \emph{"true"} and \emph{"unknown"} and the list
of expected results for queries that expect accurate answer can contain just
\emph{"true"}.

\section{Configuration}

\lstset{
    basicstyle=\footnotesize,
    string=[s]{"}{"},
    stringstyle=\color{blue},
    comment=[l]{:},
    commentstyle=\color{black},
}

The JSON file contains following fields:

\medskip
\begin{description}
\item[\texttt{file}] Path to a a file with definitions of instrumentation functions.
\item[\texttt{analyses}] List of paths to analyses plugins.
\item[\texttt{flags}] List of flags that can be set during instrumentation.
\item[\texttt{phases}] List of instrumentation phases. Each phase contains a
  list of \texttt{instructionRules}. Each rule is described with several fields:
  \begin{itemize}
    \item \texttt{findInstructions}: Sequence of instructions we are searching
    for. For each instruction in the sequence, we need to fill in an
        \texttt{instruction} field, that specifies a name of the instruction,
        \texttt{returnValue} that enables to remember the return value of the
        instruction in a given variable (can be set to "*" if the return value
        is not needed), and \texttt{operands} that enables either to match the
        operands or to remember the operand values in given variables. We can
        also optionally fill in fields \texttt{getSizeTo} and
        \texttt{getPointerInfoTo}. \texttt{getSizeTo} can be used only with
        \texttt{load}, \texttt{store} or \texttt{alloca} instruction and it
        stores size of the type of the value that is being loaded, stored or
        allocated to the given variable. \texttt{getPointerInfoTo} can be used
        only with \texttt{load} or \texttt{store} and it stores two values to
        given variables (if possible): size of the allocated memory to which
        the dereferenced pointer points to and corresponding \texttt{alloca}
        instruction. Since we can get this information only from a pointer
        analysis, this field can be used only when the analysis is available as
        a plugin.
    \item \texttt{newIstruction:} Instruction that is to be inserted. It
    contains two mandatory fields: \texttt{instruction} that specifies a name
    of the new instruction (for now, only \texttt{call} instruction is
    supported), and \texttt{operands} of the instruction. Moreover, it is
    possible to add one optional field \texttt{stripInBoundsOffsets} that
    strips off pointer casts from a given pointer (i.e. returns the value of
    the original pointer).
    \item \texttt{in:} Name of a function, in which this rule should be
    applied. Can be set to a value "*" meaning that it should be used in all
    functions.
    \item \texttt{where:} Specifies the location of insertion. It can be:
      \texttt{before} or \texttt{after} the found sequence of instructions,
      \texttt{entry} (at the entry point of the given function, \texttt{in}
      cannot be set to "*" in this case) or \texttt{return} (before every
      terminator instruction of the given function, \texttt{in} cannot be set to
      "*" in this case).
    \item \texttt{conditions:} List of conditions that have to be satisfied
    (see section~\ref{sec:conditions}). A condition consists of fields
    \texttt{query} and \texttt{expectedResult}. \texttt{Query} is a list
    where the first element is a name of a condition and other elements are
    parameters passed to the condition, \texttt{expectedResult} is a list of
    expected results of the query.
    \item \texttt{setFlags:} List of pairs \texttt{<flag, value>} that sets
      all \texttt{flags} to a corresponding \texttt{value} if the rule was
      applied. This field is optional.
    \item \texttt{remember:} Specifies, which variable will be remembered in an
    auxiliary list for later use if the rule is applied. This field is optional.

  \end{itemize}
\item[\texttt{globalVariablesRule}] A rule for instrumenting global
  variables. The rule is described with several fields:
  \begin{itemize}
    \item \texttt{findGlobals:} Contains one mandatory field
    \texttt{globalVariable} that stores a value of a global variable to the
    given variable, and one optionall field \texttt{getSizeTo} that gets the
    size of the type of the global variable.
    \item \texttt{newInstruction:} The same as in \texttt{instructionRule}.
    \item \texttt{in:} Name of a function, at the beginning of which the rule
    should be applied.
    \item \texttt{conditions:} The same as in \texttt{instructionRule}.

  \end{itemize}

\end{description}

Variables in the JSON configuration file are enclosed by the '<' and '>'
characters. These variables can be used to store some values for later use. For
example, to store an operand of a \texttt{load} instruction to variable
\texttt{<t>}, the field \texttt{operands} will be set to \texttt{["<t>"]}.
Variable \texttt{<t>} will contain in the scope of the current rule the value
of the operand of \texttt{load} instruction and it can be used e.g. as an
argument of the function call that is to be instrumented or as an argument of a
condition.

The functions whose calls are instrumented into a code must be defined in a
file specified by the \texttt{file} field in the JSON configuration. This file
has to be compiled to LLVM and after a successful instrumentation, the
definitions of functions must be linked to the instrumented module.

\begin{figure}[h]
\lstinputlisting{examples/json_example.json}
\caption{Example of an \texttt{instructionRule} in a JSON configuration file.}
\label{fig:json_example}
\end{figure}

\begin{figure}[h]
\lstinputlisting{examples/json_example2.json}
\caption{Example of an \texttt{globalVariablesRule} in a JSON configuration file.}
\label{fig:json_example2}
\end{figure}


\section{Applying Rules}

In this section, we describe an algorithm for applying the instrumentation
rules on a module loaded from the given LLVM program.

\todo{say something about parsing the rules?}

First, the rules from the JSON file are parsed and loaded into a corresponding
structure. If there are some paths to plugins specified, the plugins are
loaded and the instrumentation part begins.

The instrumentation is implemented to be staged, therefore the first step is to
process all the phases one after each other in a following way: iterate over
functions from the loaded module and check rules from the phase being processed
that are relevant for the current function. That is, take into consideration
only rules where \texttt{in} field is set to "*" or to the name of the
function. Then compare the sequences of instructions defined by these rules
(field \texttt{findInstructions}) with instructions of the current function and
if some rule matches the sequence, begin to process the rule.

To process the rule, first of all, the values of operands and return values of
the matched instructions that are noted by the rule to be saved are stored to
given variables. If the fields \texttt{getSizeTo} or \texttt{getPointerInfoTo}
are present, the demanded information is stored to the given variables. Then
all conditions are checked as described in Section~\ref{sec:conditions}. If
they are satisfied, the rule is ready to be applied. The new \texttt{call}
instruction that is to be inserted is created according to
\texttt{newInstruction} field and injected before or after the matched sequence
of instructionaccording to \texttt{where} field.

Since the parameters of the callee function might be of different types than
values that are passed as these parameters, we might need to convert them
before the insertion of the new call. In this case, we first insert a
\texttt{bitcast} instruction that performs the needed conversion. For example,
if the function that is to be called takes a 64-bit integer as a parameter, but
the value passed as this parameter is a 32-bit integer, instruction
\texttt{bitcast i32 value to i64} will be inserted before the new call
instruction.

If the rule is successfully applied, flags are set according to field
\texttt{setFlags} (if present). If field \texttt{remember} is defined, the
given value is store to an auxiliary list and can be used in later phase of
instrumentation.

At the very end, after each phase from the configuration was processed, a rule
for global variables is applied. That is, a new instruction is inserted at the
beginning of the function given in \texttt{in} field if conditions are
satisfied.

Sometimes the program might contain definitions of functions that are never
called. Such functions can be omitted from the instrumentation process if a
plugin for a pointer analysis is available. To determine what functions are
called, we first need to build a call graph from the given program. The pointer
analysis is necessary for building this graph because functions can be called
indirectly through function pointers. Then we search the graph with
breadth-first search algorithm starting from the node that represents the
\emph{main} function. All functions (or nodes precisely) that were visited
during the search are marked as reachable. All the other functions were never
called and are not instrumented.

\todo{describe cloning metadata?}

In figure~\ref{fig:json_example}, we can see an example of an
\texttt{instructionRule}. In this case, every time the tool comes across a
\texttt{load} instruction in any function (\texttt{in} is set to "*"), the only
operands of \texttt{load} is stored to a variable \texttt{<t1>}, size of the
type that is being load is stored to a variable \texttt{<t2>} and condition
\texttt{isValidPointer} is checked for all plugins (i.e. a function
\texttt{isValidPointer} is called with arguments \texttt{<t1>} and
\texttt{<t2>} by all plugins). If some plugin answered either \emph{"false"} or
\emph{"unknown"}, the condition holds and call of a function
\texttt{\_\_INSTR\_check\_pointer} with arguments \texttt{<t1>} and
\texttt{<t2>} is inserted \emph{before} the current \texttt{load} instruction.
After a successful application of this rule, flag \texttt{loadPresent} is set
to \emph{true}.

An example of a \texttt{globalVariablesRule} can be found in
figure~\ref{fig:json_example2}. The value of a global variable is stored to a
variable \texttt{<t1>} and size of the type of the global variable is stored to
a variable \texttt{<t2>}. Plugins are asked whether the given condition
\texttt{isRemembered} with argument \texttt{<t1>} holds and if the answer is
positive, new call of a function \texttt{\_\_INSTR\_remember\_global} with
arguments \texttt{<t1>} and \texttt{<t2>} is inserted at the beginning of
\emph{main}.

\section{Logging}

To sum up the instrumentation process for a concrete file, each operation is
logged with a logger. The logger notes following operations:
\begin{itemize}
  \item parsing configuration
  \item loading plugins (also lists the names of the loaded plugins)
  \item the beginning and the end of each phase
  \item ommitting a function from instrumentation
  \item rule application and instruction insertion
  \item the end of instrumentation (also logs the name of the resulting file)
\end{itemize}
The logger also logs errors such as error when parsing configuration, invalid
path to a plugin, unsupported instruction insertion, instrumentation of a
non-existing function, error when inserting a new instruction, etc. Logs can be
found in \emph{log.txt} file that is generated at the end of the
instrumentation process.

