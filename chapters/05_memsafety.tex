\section{Basic Approach}

To check memory safety, namely absence of invalid pointer dereferences, invalid
deallocations, and memory leaks, our instrumentation inserts a code that tracks
all allocated memory blocks and all memory-manipulating operations at run-time.
For every block of the memory, we maintain a record with the address and the size
of the block. The records are stored in four lists:
\begin{itemize}
  \item \stacklist for blocks allocated on the stack
  \item \heaplist for blocks allocated on the heap
  \item \globalslist for global variables
  \item \dealloclist for blocks on the heap that were already deallocated
\end{itemize}
We keep the records in the last list only to provide more precise
error descriptions. For example, the information in this list allows
us to distinguish double free error from generic invalid deallocation,
or use-after-free from vague invalid dereference error. This list can
be removed in order to reduce memory consumption.

To maintain the records, we use the following functions:
\begin{itemize}
  \item \texttt{\_\_INSTR\_remember(address, size)}
  \\Creates a record and inserts it to the \stacklist.
  \item \texttt{\_\_INSTR\_remember\_malloc(address, size)}
  \\Creates a record and inserts it to the \heaplist.
  \item \texttt{\_\_INSTR\_remember\_global(address, size)}
  \\Creates a record and inserts it to the \globalslist.
  \item \texttt{\_\_INSTR\_free(address)}
  \\Checks whether the address refers to some block allocated on the heap,
  i.e., whether there is a record with this address in the \heaplist. If such a
  record exists, it is removed from the \heaplist\ and inserted into the
  \dealloclist. If there is a record with this address, but it is found in the
  \dealloclist\, we report double free error. In all remaining cases, an invalid
  deallocation is reported.
  \item \texttt{\_\_INSTR\_destroy\_allocas()}
  \\ Since local variables on the stack are destroyed when a function
  finishes, this function removes all relevant records from the \stacklist right
  before returning from a function.
\end{itemize}

There are also two more functions that use records to check
the safety of memory operations, but they do not modify them:
\begin{itemize}
\item \texttt{\_\_INSTR\_check\_pointer(address, n)}
  \\Checks whether it is a safe operation to dereference $n$ bytes
  starting at the given address. More precisely, it checks whether
  there is a record in the \stacklist, \heaplist or the \globalslist
  covering $n$ bytes starting at the given address.  If such a record
  is found, the check is successful. If the address is covered by a
  record stored in the \dealloclist, we report a use-after-free error
  If no record covering the address is found, or there is a record
  covering the address but not all $n$ bytes starting at this address,
  we report an invalid dereference.
% \todo{NENI PRAVDA: When dereferencing a single address, we use 1 as the
% second parameter. A larger parameter is used for instrumentation of
% functions like \texttt{memset} or \texttt{memcpy}}
\item \texttt{\_\_INSTR\_check\_leaks()}
  \\Checks whether all blocks dynamically allocated on the heap have been
  freed. In other words, if there is a record in the \heaplist, then we report
  a memory leak.
\end{itemize}

The checks mentioned in the functions above
% , namely in \texttt{\_\_INSTR\_free(address)},
% \texttt{\_\_INSTR\_check\_pointer(address, n)}, and
% \texttt{\_\_INSTR\_check\_leaks()},
are in fact implemented as assertions. Hence, an error is reported if
and only if some of these asserts can be violated, i.e.~if an error
location is reachable.

Calls to the hitherto described functions are inserted into the analyzed
program to keep track of the state of the memory.
For each global variable, the instrumentation inserts a call of
\texttt{\_\_INSTR\_remember\_global} to the beginning of \emph{main} in order
to create the corresponding record. Further, the instrumentation detects memory
handling instructions in the code and inserts calls to the corresponding
\texttt{\_\_INSTR\_*} functions above or below these instructions. When
instrumenting a memory allocation instruction, we insert the call of
\texttt{\_\_INSTR\_remember} (for allocations on the stack) or
\texttt{\_\_INSTR\_remember\_malloc} (for allocations on the heap) \emph{below}
the allocation instruction as the called function needs the address of the
allocated block. In all remaining cases, the calls are inserted \emph{above} the
corresponding instruction as we want to detect a memory handling error before
the program reaches the actual error.
Calls of \texttt{\_\_INSTR\_destroy\_allocas} are instrumented \emph{above} all
\emph{return} instructions in each function. Finally, a call to
\texttt{\_\_INSTR\_check\_leaks()} is inserted at the end of \emph{main} to
check for memory leaks.

\lstset{escapeinside={<@}{@>}, columns=fullflexible, basicstyle=\ttfamily, language=llvm, style=nasm}
\begin{figure}[t]
\begin{lstlisting}
%1 = alloca i32*, align 8
<@{\color[RGB]{0, 135, 0} \%2 = bitcast i32** \%1 to i8*}@>
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_remember(i8* \%2, i64 8, i32 1)}@>
%3 = call i8* malloc(i64 4)
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_remember\_malloc(i8* \%3, i64 4, i32 1)}@>
%4 = bitcast i8* %3 to i32*
<@{\color[RGB]{0, 135,0} \%5 = bitcast i32** \%1 to i8*}@>
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_check\_pointer(i8* \%5, i64 8)}@>
store i32 %4, i32** %1, align 8
%6 = bitcast i32** %1 to i8*
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_free(i8* \%6)}@>
call void @free(i8* %6)
<@{\color[RGB]{0, 135,0} \%7 = bitcast i32** \%1 to i8*}@>
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_check\_pointer(i8* \%7, i64 8)}@>
%8 = load i32*, i32** %1
<@{\color[RGB]{0, 135,0} \%9 = bitcast i32** \%8 to i8*}@>
<@{\color[RGB]{0, 135,0} call void @\_\_INSTR\_check\_pointer(i8* \%9, i64 8)}@>
store i32 2, i32** %8, align 4
\end{lstlisting}
\caption{Basic instrumentation of a code with an invalid pointer
  dereference.}
\label{fig:example1}
\end{figure}

Figure~\ref{fig:example1} shows a simple code containing an invalid
pointer dereference. The code is instrumented with the
\texttt{\_\_INSTR\_*} function calls which keep track of memory
operations and check their safety. To begin with, the instrumentation
remembers every memory allocation, including stack variables. It may
seem redundant at first, but without any further analysis, we can not
say that a local variable is dereferenced e.g.~using a pointer, in
which case we need to have the record, otherwise we would report
invalid dereference.
%(in particular, dereference of non-allocated memory).
The memory allocated by the call to \texttt{malloc} is remembered by the call
to \texttt{\_\_INSTR\_remember\_malloc(p, 4)}. This memory is later freed and
this fact is recorded by the call to \texttt{\_\_INSTR\_free(p)}. Every access to the memory (every \texttt{load} or \texttt{store} instruction)
are checked using \texttt{\_\_INSTR\_check\_pointer}. The last call of this
function (i.e.~line~17) reveals
use-after free error. \todo{bitcasts}

%\texttt{\_\_INSTR\_free(p)} moves the record from \heaplist to \dealloclist.
%Finally, the code is instrumented with a call to
%\texttt{\_\_INSTR\_check\_pointer(r, 4)} which detects the use-after-free
%error.

Disadvantage of this basic approach is that it tracks all memory allocations and
instruments all dereferences. The amount of inserted function calls is
therefore usually very large and since the vast majority of the new code has
an effect on reachability of error locations, it cannot be removed by slicing.
